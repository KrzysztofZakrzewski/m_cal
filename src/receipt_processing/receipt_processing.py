import json
from openai import OpenAI
import os
import re
from src.dirs import DIRS
from typing import Optional, Dict, Any

# get openai client
def get_openai_client():
    return OpenAI(api_key=os.environ["OPENAI_API_KEY"])

# ===============================================================
# ðŸ“¦ loading data from receipt into json
# ===============================================================
def loading_data_from_receipt_into_json(prepared_receipt: str) -> None:
    
    # Send an image of a receipt to the OpenAI API for text extraction,
    # receive a JSON-formatted response, and save it locally as 'receipt_raw.json'.

    # Args:
    #   prepared_receipt (str): Base64-encoded image of the receipt, formatted as
    #                            'data:image/jpg;base64,...'.

    # Returns:
    #     None: The function saves the parsed receipt JSON to a file in 
    #           DIRS['temporary_json_from_receipt'].
    
    
    response = get_openai_client().chat.completions.create(
        # model="gpt-4o",
        model="gpt-4o-mini",
        temperature=0,
        messages=[
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": """
    WyciÄ…gnij informacje zawarte na paragonie z Restauracji w McDonald's w Polsce.
    Dane przedstaw w formacie JSON.
    OczekujÄ™ informacji dotyczÄ…cych nazw produtkÃ³w, iloÅ›ci, kwoty za poszczegÃ³lne produkty oraz Å‚Ä…cznej kwoty za caÅ‚y paragon.
    NiektÃ³re produkty w systemie fiskalnym mogÄ… mieÄ‡ niekonwencjonalne nazwy.
    Pod napisem "PARAGON FISKALNY" znajdujÄ… siÄ™ produkty jeden pod drugim.
    Od lewej jest jego nazwa, po prawej iloÅ›Ä‡ i naleÅ¼noÅ›Ä‡.
    â€žJeÅ›li w nazwie produktu wystÄ™puje liczba (np. Tenders 3, Tenders 5), traktuj jÄ… jako czÄ™Å›Ä‡ nazwy np: "Nuggets 6", "Tenders 3", etc. traktuj je jako 1 produkt.
    Dodatkowo potrzebujÄ™ informacji o:
    - dacie: rok, misiÄ…Ä‡ i dzieÅ„ oraz godzinÄ™ zakupu.
    - Miejscu zakupu: miasto, ulica.
    UsuÅ„ z wszystkich kluczy i wartoÅ›ci dokÅ‚adnie te znaki: kropkÄ™ (.), gwiazdkÄ™ (*), podÅ‚ogÄ™ (_).
    JeÅ¼eli podÅ‚oga (_) jest miÄ™dzy literami zastÄ… spacjÄ… ( )
    Nie zostawiaj Å¼adnego z nich.
    PrzykÅ‚adowa struktura (na paragonie bÄ™dÄ… siÄ™ znajdowaÄ‡ rÃ³Å¼ne produkty to przykÅ‚ad):
    {
    {
    "lody w wafelku z polewÄ… karmelowÄ…": {
        "iloÅ›Ä‡": ...,
        "kwota": ...
    },
    "cheeseburger": {
        "iloÅ›Ä‡": ...,
        "kwota": ...
    },
    "lody w kubku z polewÄ… truskawkowÄ…": {
        "iloÅ›Ä‡": ...,
        "kwota": ...
    },
    "Big Mac": {
        "iloÅ›Ä‡": ...,
        "kwota": ...
    },
    "Å‚Ä…czna kwota za paragon": ...,
    "data": "yyyy-mm-dd",
    "godzina": "hh:mm",
    "miasto": "...",
    "ulica": "..."
    }

    tylko dane jako JSON, bez Å¼adnych komentarzy
    """
                    },
                    {
                        "type": "image_url",
                        "image_url": {
                            "url": prepared_receipt,
                            "detail": "high"
                        },
                    },
                ],
            }
        ],
    )

        # saving the calorie table as json
        # temporary_json_from_receipt_PATH
    json_from_receipt = response.choices[0].message.content.replace('```json','').replace('```','').strip()
    with open(DIRS['temporary_json_from_receipt']/f'receipt_raw.json', 'w') as f:
            f.write(json_from_receipt)

# ===============================================================
# ðŸ“¦ PARSIN JSON_RAW
# ===============================================================
def parsing_data_from_receipt_raw_into_json() -> Optional[Dict[str, Any]]:
    # Load the raw receipt JSON generated by OpenAI, send it back to the model for 
    # normalization (e.g., mapping Polish product names to English equivalents),
    # and save the cleaned version as 'receipt_parsed.json'.

    #Returns:
    #    Optional[Dict[str, Any]]: Parsed and cleaned JSON data if successful, 
    #                              otherwise None if the file doesn't exist or is invalid.

    # Path to the raw JSON file
    receipt_raw_path = DIRS['temporary_json_from_receipt'] / "receipt_raw.json"

    # ðŸ”¹ If the file does not exist, stop gracefully
    if not receipt_raw_path.exists():
        return None

    # ðŸ”¹ Try loading the raw JSON (first time) to prepare it as a string for the prompt
    try:
        with open(receipt_raw_path, "r", encoding="utf-8") as f:
            data = json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        # If the file is empty or corrupted â€” stop without raising an error
        return None

    # ðŸ”¹ Convert JSON to string for prompt input
    data_str_for_AI_maping = json.dumps(data, indent=2, ensure_ascii=False)

    # ðŸ”¹ Reload the file (second read â€” as in the original code)
    with open(receipt_raw_path, "r", encoding="utf-8") as f:
        data = json.load(f)
    
    prompt = f"""
    Masz poniÅ¼szy JSON z danymi pochodzÄ…cymi z paragonu z restauracji McDonald's Polska:
    {data_str_for_AI_maping}

    Twoim zadaniem jest:
    1. ZamieniÄ‡ TYLKO nazwy produktÃ³w (klucze na najwyÅ¼szym poziomie) na ich czytelne odpowiedniki w jÄ™zyku polskim.
    2. Nie zmieniaj Å¼adnych podstruktur:
    - Klucze "iloÅ›Ä‡" i "kwota" muszÄ… pozostaÄ‡ takie same.
    - WartoÅ›ci tych kluczy pozostajÄ… bez zmian.
    3. Nie zmieniaj ani nie ruszaj pÃ³l: "Å‚Ä…czna kwota za paragon", "data", "godzina", "miasto", "ulica".
    4. JeÅ¼eli w nazwie produktu wystÄ™pujÄ… litery "HM" â€” usuÅ„ ten produkt z wynikowego JSON-a.
    5. Nie twÃ³rz nowych produktÃ³w ani nie poprawiaj nazw istniejÄ…cych (np. NIE zmieniaj "Cheeseburger" â†’ "McCheeseburger").
    6. ZwrÃ³Ä‡ TYLKO poprawiony JSON, bez Å¼adnych komentarzy ani tekstu opisu.

    Mapowanie nazw produktÃ³w:
    "FL Wan Lio Czek": "McFlurry o smaku waniliowym KitKat z polewÄ… o smaku czekoladowym",
    "WrapChrup Klas": "McWrap ChrupiÄ…cy Klasyczny",
    "Frytki Mal Pol": "Frytki MaÅ‚e",
    "FrytkiMala Por.": "Frytki MaÅ‚e",
    "Frytki M": "Frytki Åšrednie",
    "Frytki Srednie": "Frytki Åšrednie",
    "Sos Smietanowy": "Sos Åšmietanowy",
    "Tenders 3": "Chicken Tenders 3 szt.",
    "Sos Siri Mayo": "Sos Sriracha Mayo",
    "Kanapka Chikker": "Chikker",
    "Ketchup Platny": "Ketchup",
    "Kaj Wie Wiel": "Wieloziarnista Kajzerka Kurczak Premium",
    "MuffinWiepJajko": "McMuffin Wieprzowy z Jajkiem",
    "Wafel Czekolada": "Lody o smaku waniliowym z polewÄ… o smaku czekoladowym",
    "Kubek Czekolada": "Lody o smaku waniliowym z polewÄ… o smaku czekoladowym",
    "Kubek Karmel": "Lody o smaku waniliowym z polewÄ… karmelowÄ…",
    "Wafel Karmel": "Lody o smaku waniliowym z polewÄ… karmelowÄ…",
    "Jalapeno Burger": "JalapeÃ±o Burger"
    "Sos SlodkoKwasny": "Sos SÅ‚odko-KwaÅ›ny"

    ZwrÃ³Ä‡ poprawiony JSON.
    """

    response = get_openai_client().chat.completions.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": prompt}],
    )
    new_json_text = response.choices[0].message.content

    # Extract JSON object from model's text response
    match = re.search(r'(\{.*\})', new_json_text, re.DOTALL)
    if match:
        json_only = match.group(1)
        new_data = json.loads(json_only)
    else:
        raise ValueError("Nie znaleziono poprawnego JSON-a w odpowiedzi modelu")

    # Save the parsed data to a new file
    with open(DIRS['temporary_json_parsed']/"receipt_parsed.json", "w", encoding="utf-8") as f:
        json.dump(new_data, f, indent=2, ensure_ascii=False)